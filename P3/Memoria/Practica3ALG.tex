\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{csvsimple}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\renewcommand*\contentsname{Índice} %Nombre del indice

\begin{document}
\lstset{
	basicstyle=\footnotesize,
	extendedchars=true,
	literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1 {ú}{{\'u}}1 {ó}{{\'o}}1,
	backgroundcolor=\color{black!5}
	}
	
\begin{titlepage}
	\centering
	{\includegraphics[scale=0.5]{Logo_UGR.png}\par}
	\vspace{1cm}
	{\bfseries\Large Escuela T\'ecnica Superior de Ingeniería Informática y Telecomunicaciones \par}
	\vspace{2.5cm}
	{\scshape\Huge Pr\'actica 3: Algoritmos Greedy \par}
	\vspace{3cm}
	{\itshape\Large Doble Grado Ingeniería Informática y Matemáticas}
	\vfill
	{\Large Autores: \par}
	{\Large Jose Alberto Hoces Castro\par}
	{\Large Javier Gómez López \par}
	{\Large Moya Mart\'in Castaño \par}
	\vfill
	{\Large Mayo 2022 \par}
\end{titlepage}

\thispagestyle{empty}
\null
\vfill

%%Información sobre la licencia
\parbox[t]{\textwidth}{
  \includegraphics[scale=0.05]{by-nc-sa.png}\\[4pt]
  \raggedright % Texto alineado a la izquierda
  \sffamily\large
  {\Large Este trabajo se distribuye bajo una licencia CC BY-NC-SA 4.0.}\\[4pt]
  Eres libre de distribuir y adaptar el material siempre que reconozcas a los\\
  autores originales del documento, no lo utilices para fines comerciales\\
  y lo distribuyas bajo la misma licencia.\\[4pt]
  \texttt{creativecommons.org/licenses/by-nc-sa/4.0/}
}

\newpage

\tableofcontents

\newpage

\section{Introducción}

El objetivo de esta práctica es aprender a implementar y utilizar algoritmos \textit{``greedy''} o voraces para resolver problemas de manera rápida aunque no por ello menos óptima. Para ello, se plantean los siguientes dos problemas:

\begin{itemize}
	\item \textbf{Ejercicio 1} (Contenedores): Se quiere rellenar un buque mercante con una cierta capacidad de peso con contenedores, cada uno de los cuales tiene su propio peso.
	\item \textbf{Ejercicio 2} (TSP): El problema del viajero. Se quiere recorrer una serie de ciudades, pasando por ellas solo una vez y volviendo al punto de partida. Se quiere encontrar la ruta más óptima.
\end{itemize}

\section{Desarrollo}

Para el primer ejercicio, nos centraremos en identificar el problema de los contenedores como un problema Greedy identificando sus características. También, justificaremos los optimalidad o la no optimalidad de los algoritmos Greedy desarrollados.
\\
\\
Para el análisis de los algoritmos del viajante de comercio que desarrollaremos, hemos realizado los siguientes pasos:

\begin{enumerate}
	\item Un \textbf{análisis teórico} de los algoritmos usando las técnicas vistas en clase.
	
	\item Un \textbf{análisis empírico} donde hemos ejecutado los algoritmos en nuestros ordenadores bajo las mismas normas y condiciones. Hemos compilado usando la optimización \texttt{-Og}. Además, hemos usado como \textit{datasets} de pruebas los datos proporcionados por la profesora en el caso del TSP, y valores aleatorios de los pesos de los contenedores para el primer problema. Por otro lado, para automatizar el proceso, hemos creado unos \textit{scripts} de generació  de datos de prueba y de ejecución de nuestros programas. Hemos ejecutado cada algoritmo 15 veces en cada uno de los tamaños probados, y hemos hecho la media de ellos para reducir perturbaciones que puedan alterar el resultado.
	
	\item Un \textbf{análisis híbrido} donde hemos tomado los datos de cada uno de los alumnos del grupo y hemos hallado la \(K\) (constante oculta). Para ello hemos usado gnuplot.
\end{enumerate}

\subsection{Ejercicio 1. Contenedores}

El enunciado del problema es el siguiente: \textit{Se tiene un buque mercante cuya capacidad de carga es de } K \textit{toneladas y un conjunto de contenedores \(c_1, \dotsc, c_n\) cuyos pesos respectivos son \(p_1, \dotsc, p_n\) (expresados también en toneladas). Teniendo en cuenta que la capacidad del buque es menor que la suma total de los pesos de los contenedores: }

\begin{itemize}
	\item \textit{Diseñe un algoritmo que maximice el número de contenedores cargados, y demuestre su optimalidad.}
	\item \textit{Diseñe un algoritmo que intente maximizar el número de toneladas cargadas.}
\end{itemize}

\subsubsection{Primer ejercicio}
	Nuestro objetivo es que podamos cargar el máximo número de contenedores en un buque mercante de K toneladas. Para ello, el algoritmo que nosotros proponemos es tomar los contenedores, ordenarlos de menor a mayor peso, y comenzar añadiendo los de menor peso. De esta forma, podemos cargar más contenedores, ya que si empezásemos por los de pesos intermedios o mayores, acabaríamos cargando menos. 
	\\
	\\
	Veamos las 6 características de nuestro problema Greedy:
	\begin{itemize}
		\item \textbf{Un conjunto de candidatos}: En este caso, los contenedores a cargar.
		\item \textbf{Una lista de candidatos ya usados}: Los contenedores que ya han sido cargados.
		\item \textbf{Un criterio que dice cuándo un conjunto de candidatos forma una solución}: El criterio es que la suma de los pesos de un conjunto de contenedores no sea superior a las K toneladas del buque.
		\item \textbf{Un criterio que dice cuándo un conjunto de candidatos es factible (podrá llegar a ser una solución)}: el conjunto de contenedores que se evalúe no debe superar en peso las K toneladas del buque.
		\item \textbf{Una función de selección que indica en cualquier instante cuál es el candidato más prometedor de los no usados todavía}: El contenedor de menor peso de los que aún no están cargados, de ahí que los ordenemos de menor a mayor peso.
		\item \textbf{La función objetivo que intentamos optimizar}: El número de contenedores a cargar, es lo que queremos maximizar.
	\end{itemize}

	A continuación pasamos a mostrar el código de nuestro algoritmo. Para representar el conjunto de contenedores, hemos considerado un vector de enteros, siendo cada entero el peso de cada contenedor. Para asegurarnos de que la suma de los pesos de todos los contenedores supera a las K toneladas del buque, el vector es de dimensión K con enteros aleatorios desde 0 hasta K (en nuestro código lo representamos por el parámetro n, introducido por el usuario). Nuestra función devuelve el número de contenedores que se han podido cargar:
	
	\lstinputlisting[language=C++]{./Codes/contenedores1.cpp}
	
	\begin{itemize}
		\item \textbf{Estudio de la optimalidad}
		\\
		\\
	\end{itemize}
	
\subsubsection{Segundo ejercicio}

	En este segundo ejercicio, lo que queremos es maximizar las toneladas cargadas en el buque sin sobrepasar su capacidad total. Para ello, seguimos el pensamiento inverso al planteado en el anterior ejercicio. Como lo que nos interesa es cargar el máximo de toneladas posibles, empezaremos cargando aquellos contenedores cuyo peso sea el más grande. Para ello, los ordenamos de mayor a menor peso, justo al contrario que antes. Identificamos las 6 características de un problema Greedy:
	
	\begin{itemize}
		\item \textbf{Un conjunto de candidatos}: En este caso, los contenedores a cargar.
		\item \textbf{Una lista de candidatos ya usados}: Los contenedores que ya han sido cargados.
		\item \textbf{Un criterio que dice cuándo un conjunto de candidatos forma una solución}: El criterio es que la suma de los pesos de un conjunto de contenedores no sea superior a las K toneladas del buque.
		\item \textbf{Un criterio que dice cuándo un conjunto de candidatos es factible (podrá llegar a ser una solución)}: el conjunto de contenedores que se evalúe no debe superar en peso las K toneladas del buque.
		\item \textbf{Una función de selección que indica en cualquier instante cuál es el candidato más prometedor de los no usados todavía}: El contenedor de mayor peso de los que aún no están cargados, de ahí que los ordenemos de mayor a menor peso.
		\item \textbf{La función objetivo que intentamos optimizar}: El número de toneladas a cargar, es lo que queremos maximizar.
	\end{itemize}

	En el código del algoritmo, al igual que antes, simulamos los contenedores con sus respectivos pesos con un vector de enteros, el cual ordenamos de mayor a menor usando el sort de la STL. Se van sumando los pesos hasta que se sobrepase el tope de toneladas del buque. Nuestra función devuelve el número de toneladas que se han podido cargar en total:
	
	\lstinputlisting[language=C++]{./Codes/contenedores2.cpp}
	
	\begin{itemize}
		\item \textbf{Estudio de la optimalidad}
		\\
		\\
		Sin embargo, en este caso nuestro algoritmo no nos da la solución óptima. Veámoslo con un contraejemplo. Con n = 10, imaginemos que tenemos el vector [5, 4, 6, 1, 1, 2, 7, 9, 8, 3].
		Nuestro algoritmo lo ordenaría de mayor a menor, obteniendo el vector [9, 8, 7, 6, 5, 4, 3, 2, 1, 1]. Tras esto, se incluiría el contenedor de peso 9, pero el siguiente ya no sería posible cargarlo ya que 9 + 8 = 17 $>$ 10. La solución óptima en este caso sería tomar un contenedor de peso 1, otro de 2, otro de 3 y otro de 4, aprovechando así las 10 toneladas en su totalidad.
	\end{itemize}
	
\subsection{Ejercicio 2. El problema del viajante de comercio}

El enunciado del problema es el siguiente: \textit{dado un conjunto de ciudades y una matriz con las distancias entre todas ellas, un viajante debe recorrer todas las ciudades exactamente una vez, regresando al punto de partida, de forma tal que la distancia recorrida sea mínima.}

Además, se nos pide enfocarlo usando dos heurísticas distintas:
\begin{itemize}
	\item \textbf{Vecino más cercano}: dada una ciudad inicial \(v_0\), se agrega como ciudad siguiente aquella \(v_i\) (no incluida en el circuito) que se encuentre más cercana a \(v_0\). El procedimiento se repite hasta que todas las ciudades se hayan visitado.
	\item \textbf{Inserción}: la idea es comenzar con un recorrido parcial, que incluya algunas de las ciudades, y luego extender este recorrido insertando las ciudades restantes mediante algún criterio de tipo greedy.
\end{itemize}

Además, se debe proponer por parte del equipo otra heurística propia para resolver el problema.

\subsubsection*{Elementos comunes}
A lo largo de la solución del problema usaremos la siguiente notación para todas las heurísticas a desarrollar:
\begin{itemize}
	\item \(n\) es el \textbf{número de ciudades}.
	\item \(D\) es la \textbf{matriz de distancias}.
	\item \(r\) es el \textbf{vector de recorrido}, que contiene unra ruta que pasa por todas las ciudades, es decir, \(n\) elementos no repetidos.
	\item \(W_r\) es el \textbf{coste} de un recorrido, es decir, la distancia de un recorrido \(r\).
\end{itemize}

Adicionalmente, se han implementado una serie de funciones comunes a todas las heurísticas trabajadas en esta práctica:

\lstinputlisting[language=Python]{./Codes/common_functions.py}

Hemos definido una ``estructura'' \texttt{Point} para representar los puntos, una función \texttt{parse\_input} para parsear el input según el formato dado en los archivos de clase, \texttt{distance} que mide la distancia entre dos puntos, \texttt{gen\_distance\_matrix} que genera la matriz de distancias dada una lista de puntos y \texttt{get\_road\_distance} que da la longitud de un vector de recorrido.

\subsubsection{Heurística del vecino más cercano}

Este algortimo \textit{greedy} es muy simple:
\begin{enumerate}
	\item Partimos de un nodo cualquiera (en nuestro caso siempre usaremos el primer elemento de nuestro \textit{input}).
	\item Encontramos el nodo más cercano a este nodo, y los añadimos al recorrido.
	\item Repetimos el proceso hasta cubrir todos los nodos.
\end{enumerate}

Hacemos uso del siguiente código:
\lstinputlisting[language=Python]{./Codes/cercania.py}

En este programa, básicamente tenemos lo que hacemos es partir de el primer punto pasado en el \textit{input} y tras ello vamos buscando los nodos más cercanos sin repetir los ya añadidos. Primero parseamos el input, generamos la matriz de distancia, y la vamos transformando para descartar los nodos ya considerados. 

\subsubsection*{Análisis empírico}
A continuación, mostramos los resultados obtenidos tras probar nuestro programa con los \textit{datasets} proporcionados en la asignatura:

\begin{itemize}
	\item \texttt{ulysses16.tsp}: El mejor orden para este \textit{dataset} (teniendo en cuenta el orden del fichero original) es:
	\[
		[0,7,15,12,11,13,6,5,14,4,8,9,3,1,2,10]
	\]
	
	y la distancia a recorrer es: 103
	
	Si representamos los puntos con el recorrido generado obtenemos el siguiente gráfico:
	
	\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{./Images/ulysses_cercania.png}
	\caption{Gráfica de Ulysses mediante el Vecino más cercano}
	\end{figure}
	
	\item \texttt{bayg29.tsp}: El mejor orden para este \textit{dataset} (teniendo en cuenta el orden del fichero original) es:
	\[
		[0,27,5,11,8,4,20,1,19,9,3,14,17,13,21,16,10,18,24,6,22,26,7,23,15,12,28,25,2]
	\]
	
	y la distancia a recorrer es: 10209
	
	Si representamos los puntos con el recorrido generado obtenemos el siguiente gráfico:
	
	\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{./Images/bayg_cercania.png}
	\caption{Gráfica de Bayg mediante el Vecino más cercano}
	\end{figure}
	
	\item \texttt{eil76.tsp}: El mejor orden para este \textit{dataset} (teniendo en cuenta el orden del fichero original) es:
	\[
		[0,72,32,62,15,2,43,31,8,38,71,57,9,37,64,10,65,52,13,18,34,6,7,45,33,51,26,44,28,
	\]
	\[
		47,46,20,73, 27, 61,1,29,3,74,75,66,25,11,39,15,50,5,67,4,36,19,69,59,70,35,68,60,2
	\]
	\[
		1,41,40,42,22,55,48,23,17,49,24,54,30,58,53,12,56,14,63]
	\]
	
	y la distancia a recorrer es: 642
	
	Si representamos los puntos con el recorrido generado obtenemos el siguiente gráfico:
	
	\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{./Images/eil_cercania.png}
	\caption{Gráfica de Eil mediante el Vecino más cercano}
	\end{figure}
\end{itemize}

\subsubsection{Heurística por inserción}

\subsubsection{Heurística propia: perturbaciones}

Este enfoque, de nuevo \textit{greedy}, realiza las perturbaciones indicadas por un parámetro sobre un recorrido dado para intentar mejorarlo. Tenemos el siguiente código:
\lstinputlisting[language=Python]{./Codes/perturbaciones.py}

Primero lo que hacemos es obtener una solución mediante la heurística del vecino más cercano. Tras esto, tenemos la función \texttt{get\_worst\_node} que dado un recorrido, haya el nodo que más dista de su nodo siguiente. Por ello es necesario usar ya una solución previa (mediante el vecino más cercano) para calcular este ``nodo peor''. Por último, tenemos la función \texttt{perturbate} que prueba todas las posibles permutaciones que podemos hacer desde el respectivo ``peor nodo'' y se queda con la mejor de ellas.

\subsubsection*{Análisis empírico}

A continuación, mostramos los resultados obtenidos tras probar nuestro programa con los \textit{datasets} proporcionados en la asignatura:
\begin{itemize}
	\item \texttt{ulysses16.tsp}: Aplicando 10 perturbaciones, obtenemos que el mejor orden (teniendo en cuenta el orden del fichero original):
	\[
		[0,7,15,12,11,13,6,5,14,4,8,9,2,1,3,10]
	\]
	y su distancia es 101.

	Si representamos los puntos con el recorrido generado para 10 perturbaciones obtenemos el siguiente gráfico:
	\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{./Images/ulysses_perturbaciones.png}
	\caption{Gráfica de Ulysses mediante perturbaciones}
	\end{figure}
	
	\newpage
	
	\item \texttt{bayg29.tsp}: Aplicando 10 perturbaciones, obtenemos que el mejor orden (teniendo en cuenta el orden del fichero original):
	\[
		[0,27,5,11,8,4,20,1,19,9,3,14,17,13,21,16,10,18,24,6,22,26,7,23,15,12,28,25,2]
	\]
	y su distancia es 10209.

	Si representamos los puntos con el recorrido generado para 10 perturbaciones obtenemos el siguiente gráfico:
	\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{./Images/bayg_perturbaciones.png}
	\caption{Gráfica de Bayg mediante perturbaciones}
	\end{figure}
	
	\item \texttt{eil76.tsp}: Aplicando 10 perturbaciones, obtenemos que el mejor orden (teniendo en cuenta el orden del fichero original):
	\[
		[0,72,32,62,15,2,43,31,8,38,71,57,9,37,64,10,65,52,13,18,34,6,7,45,33,51,26,44,28,
	\]
	\[
		47,46,20,73,27,61,1,29,3,74,75,66,25,11,39,16,50,5,67,4,36,19,69,59,70,35,68,60,2,
	\]
	\[
		1,41,40,42,22,55,48,23,17,49,24,54,30,58,53,12,56,14,63]
	\]
	y su distancia es 642.

	Si representamos los puntos con el recorrido generado para 10 perturbaciones obtenemos el siguiente gráfico:
	
	\newpage
	\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{./Images/eil_perturbaciones.png}
	\caption{Gráfica de Eil mediante perturbaciones}
	\end{figure}
\end{itemize}
\end{document}